PROGRAM Crunch


! This batch-processing program is used to crunch data in many ways.

! Programmer: Marshall Buhl
!             National Wind Technology Center
!             National Renewable Energy Laboratory


USE                                AASubs
USE                                CCSubs
USE                                CrunchIO
USE                                CrunchSubs
USE                                DataMod
USE                                ExtEventSubs
USE                                ExtrValuSubs
USE                                FilterSubs
USE                                LRSubs
USE                                MoveAverSubs
USE                                PLSubs
USE                                PMFSubs
USE                                ProgGen
USE                                RFSubs
USE                                StatsSubs

IMPLICIT                           NONE


   ! Local declarations.

REAL(ReKi)                      :: AzimuthS

INTEGER                         :: AA_Col
INTEGER                         :: Fi
INTEGER                         :: Fil
INTEGER                         :: IB
INTEGER                         :: IC
INTEGER                         :: IOS
INTEGER                         :: IR

LOGICAL                         :: Error

CHARACTER(50)                   :: FrmtH
CHARACTER(50)                   :: FrmtN
CHARACTER(71)                   :: FrmtProg = '(/''Modified data from "'',A,''" generated by '',A,A,'' on '',A,'' at '',A,''.'')'



   ! Set the program name and version number.

CALL SetProg


   ! Initialize the NWTC Library, which will initialize Pi-based constants.

CALL NWTC_Init ( ProgName, ProgVer )


   ! Print out program and library name, version, and date.

CALL DispNVD


   ! Check for command-line arguments.

CALL Check_Args


   ! Get input file information.

CALL GetParams


   ! Find the biggest and smallest numbers in the computer.

Biggest  = HUGE( 1.0 )
Smallest = TINY( 1.0 )


   ! If we are autodetecting the data-file format, do so now.

IF ( AutoCols )  THEN

   CALL DetectCols

ENDIF


   ! Let's calculate some other numbers of columns.

NonAACols = NumCols + NumCChan + NumMA + NumRoseCh
TotCols   = NonAACols + NumAACols


   ! Add calculated channels.

IF ( NumCChan > 0 )  THEN

   CALL AddCC

   DO IC=1,NumCChan
      CALL CC_Init ( IC )
   ENDDO ! IC

ENDIF

IF ( NumMA     > 0 )  CALL AddMAChans
IF ( NumRoses  > 0 )  CALL AddRoseChans
IF ( NumAACols > 0 )  CALL AddAACols


   ! Check the remainder of the input.

CALL CheckInp


    ! If we are autodetecting the data records, do so now.  We use all records for FAST binary files.

IF ( ( .NOT. FASTbin ) .AND. ( NumRecs == 0 ) )  CALL DetectRecs


   ! Allocate many of the arrays.

CALL Alloc


   ! Generate formats for outputting modified data, if requested.

IF ( Out_Data )  THEN

   IF ( TabDelim )  THEN
      FrmtH = "(   (A,:,'"//Tab//"'))"
      FrmtN = "(   ("//RealFmt//",:,'"//Tab//"'))"
   ELSE
      FrmtH = "(   "//TextFmt//")"
      FrmtN = "(   ("//TRIM(RealFmt)//"))"
   ENDIF

   WRITE (FrmtH(2:4),'(I3)')  TotCols
   WRITE (FrmtN(2:4),'(I3)')  TotCols

ENDIF


   ! Process all the specified input files.

BadFiles  = 0
GoodFiles = 0

DO Fi=1,NumFiles


      ! Read the data.  Jump to end of this loop if the file could not be read.

   IF ( FASTbin )  THEN
      CALL GetFASTbinData ( Fi, GoodFiles+1, Error )
   ELSE
      CALL ReadFData ( Fi, GoodFiles+1, Error )
   END IF ! ( FASTbin )

   IF ( Error )  THEN
      BadFiles = BadFiles + 1
      BadList(BadFiles) = FileName(Fi)
      CYCLE
   ENDIF

   GoodFiles = GoodFiles + 1

   FileName(GoodFiles) = FileName(Fi)
   RootName(GoodFiles) = RootName(Fi)


      ! Filter the data, if requested.

   IF ( NumFilt > 0 )  CALL Filter ( GoodFiles )

ENDDO ! Fi


   ! Did we successfully read any files?

IF ( GoodFiles == 0 )  THEN
   CALL ProgAbort ( ' Crunch could not read any of the specified data files.', TimeWait=2.0, ErrLevel=1 )
ENDIF


IF ( Aggregate )  THEN
   CALL WrScr1 ( ' =======================================================' )
   CALL WrScr  ( ' For the aggregate of all files:' )
ENDIF


   ! If appropriate, initialize the statistics.

IF ( Aggregate )  THEN
   AnalRecs = GoodFiles*NumRecs
   CALL StatInit ( 1 )
ELSE
   AnalRecs = NumRecs
ENDIF


   ! Create any requested calculated channels.

IF ( NumCChan > 0 )  CALL CalcChan


   ! Create any requested moving-average channels.

IF ( NumMA > 0 )  CALL MoveAver


   ! Create any requested load roses.

IF ( NumRoses > 0 )  CALL LoadRose


   ! Are we doing azimuth averages?  Are they aggregate or individual AAs?

IF ( Aggregate .AND. ( NumAACols > 0 ) )  CALL AzimCalc ( 0 )


   ! Loop through all the files.

DO Fi=1,GoodFiles


   IF ( .NOT. Aggregate )  THEN
      CALL WrScr1 ( ' =======================================================' )
      CALL WrScr  ( ' For file "'//TRIM( FileName(Fi) )//'":' )
   ENDIF


      ! If requested, loop through all the records to add the azimuth averaged channels.

   IF ( NumAACols > 0 )  THEN


         ! If we're not doing aggregates, calculate azimuth averages for this file.
         ! Set the proper file index for the AziAver array.

      IF ( Aggregate )  THEN
         Fil = 1
      ELSE
         Fil = Fi
         CALL AzimCalc ( Fi )
      ENDIF


      DO IR=1,NumRecs

         IB = AzimBin( Fi, IR , AzimuthS )

         DO IC=1,NumAACols
            AA_Col = NonAACols+IC
            ConvData(AA_Col,IR,Fi) = AzimAver( Fil, IC, IB, AzimuthS )
            ConvData(AA_Col+NumAACols,IR,Fi) = ConvData(AA_Cols(IC),IR,Fi) - ConvData(AA_Col,IR,Fi)
         ENDDO ! IC

      ENDDO ! IR

   ENDIF


      ! If requested, modify the peaks by fitting them with a quadratic.

   IF ( Do_PF )  CALL PeakFind ( Fi )


      ! See if we should output the modified data.

   IF ( Out_Data )  THEN


         ! Get date and time for output file.

      DateStr = CurDate()
      TimeStr = CurTime()


         ! Open the output file.  Add a header.

      CALL GetNewUnit ( OU )
      OPEN ( OU , FILE=Trim( RootName(Fi) )//'.mod' , STATUS='UNKNOWN' , FORM='FORMATTED' , IOSTAT=IOS )

      IF ( IOS /= 0 )  THEN
         CALL ProgAbort ( ' Warning.  The output file "'//Trim( RootName(Fi) )//'.mod" could not be opened.')
      END IF

      WRITE (OU,FrmtProg)  TRIM( FileName(Fi) ), TRIM( ProgName ), TRIM( ProgVer ), DateStr, TimeStr
      IF ( Do_PF )  THEN
        WRITE (OU,'(A,/)')  'The peak-finding algorithm was used.'
      ELSE
        WRITE (OU,'(A,/)')  'The peak-finding algorithm was not used.'
      ENDIF

      IF ( TabDelim )  THEN

         WRITE (OU,FrmtH)  ( Titles(IC), IC=1,TotCols )

         IF ( HaveUnits )  THEN
            WRITE (OU,FrmtH)  ( Units(IC), IC=1,TotCols )
         ENDIF

      ELSE

         WRITE (OU,FrmtH)  ( ADJUSTR( Titles(IC) ), IC=1,TotCols )

         IF ( HaveUnits )  THEN
            WRITE (OU,FrmtH)  ( ADJUSTR( Units(IC) ), IC=1,TotCols )
         ENDIF

         WRITE (OU,FrmtH)  ( '----------', IC=1,TotCols )

      ENDIF

      CALL WrScr ( ' Writing modified data to file "'//TRIM( RootName(Fi) )//'.mod".' )
      CALL WrScr ( ' ' )

   ENDIF


      ! If appropriate, initialize statistics.

   IF ( .NOT. Aggregate )  CALL StatInit ( Fi )


      ! Go back through all the modified data to calculate statistics and (possibly) output data.

   DO IR=1,NumRecs


         ! Update the sums for means and also mins and maxes.

      IF ( Aggregate )  THEN
         CALL StatUpd (  1 , Fi , IR )
      ELSE
         CALL StatUpd ( Fi , Fi , IR )
      ENDIF


      IF ( Out_Data )  THEN


            ! Print out a status every 10000 records.

         IF ( MOD( IR , 10000 )  .EQ. 0 )  THEN
            CALL WrOver ( '  Writing record #'//TRIM( Int2LStr( IR ) )//'.' )
         ENDIF


            ! Output the modified data.

         WRITE (OU,FrmtN)  ( ConvData(IC,IR,Fi), IC=1,TotCols )

      ENDIF


   ENDDO ! IR


         ! Close the output file if appropriate.

   IF ( Out_Data )  THEN

      CALL WrOver ( '  '//TRIM( Int2LStr( NumRecs ) )//' records were written.' )

      CLOSE ( OU )

   ENDIF


      ! If appropriate, perform the analyses.

   IF ( .NOT. Aggregate )  THEN
      CALL Stats ( Fi )
      IF ( ( NumAACols > 0 )  .AND. Out_AA )  CALL Write_AA ( Fi )
      IF (   NumPLCh   > 0                 )  CALL PeakList ( Fi )
      IF (   NumPMF    > 0                 )  CALL PMF      ( Fi )
      IF (   NumRFCols > 0                 )  CALL Rainflow ( Fi )
      IF (   NumEEGrps > 0                 )  CALL FindEEs  ( Fi )
   ENDIF


ENDDO ! Fi


   ! If appropriate, perform the analyses.

IF ( Aggregate )  THEN
   CALL Stats ( 1 )
   IF ( ( NumAACols > 0 )  .AND. Out_AA )  CALL Write_AA ( 0 )
   IF (   NumPLCh   > 0                 )  CALL PeakList ( 1 )
   IF (   NumPMF    > 0                 )  CALL PMF      ( 1 )
   IF (   NumRFCols > 0                 )  CALL Rainflow ( 1 )
   IF (   NumEEGrps > 0                 )  CALL FindEEs  ( 1 )
ENDIF


   ! If appropriate, deallocate some of the RF arrays.

IF ( NumRFCols > 0 )  Then

   DEALLOCATE ( MaxMean )
   DEALLOCATE ( MaxRng  )
   DEALLOCATE ( MinMean )

ENDIF


   ! If appropriate, generate the summary files.

IF ( Out_Sumry )  THEN

   CALL SumryOpen

   DO Fi=1,GoodFiles
      CALL SumryUpd ( Fi )
   ENDDO ! Fi


      ! If all of the requested input files could not be read,
      ! append the list of bad files to the output.

   DO IC=1,NumSFCols
      IF ( BadFiles > 0 )  CALL WrBadList ( IC + 20 )
      CLOSE ( IC + 20 )
   ENDDO ! IC

ENDIF


   ! If appropriate, generate the extrapolation files.

IF ( ExtStats )  THEN

   DO IC=1,NumESCols

     IF ( ExtHrs(IC) > 0.0 ) THEN
       CALL ExtrapOpen(IC)
       CLOSE ( IC + 20 )
     ENDIF

   ENDDO ! IC

ENDIF


   ! We're outta here.

CALL WrScr ( ' =======================================================' )
CALL NormStop


END PROGRAM Crunch
